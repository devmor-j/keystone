import path from 'path';
import { createRequire } from 'module';
import { printSchema, GraphQLSchema } from 'graphql';
import * as fs from 'fs-extra';
import { getGenerator, formatSchema } from '@prisma/sdk';
import { format } from 'prettier';
import type { KeystoneConfig } from './types';
import { confirmPrompt, shouldPrompt } from './lib/prompts';
import { printGeneratedTypes } from './lib/schema-type-printer';
import { ExitError } from './scripts/utils';
import { initialiseLists } from './lib/core/types-for-lists';
import { printPrismaSchema } from './lib/core/prisma-schema';

export function getSchemaPaths(cwd: string) {
  return {
    prisma: path.join(cwd, 'schema.prisma'),
    graphql: path.join(cwd, 'schema.graphql'),
  };
}

type CommittedArtifacts = {
  graphql: string;
  prisma: string;
};

export function getFormattedGraphQLSchema(schema: string) {
  return format(
    '# This file is automatically generated by Keystone, do not modify it manually.\n' +
      '# Modify your Keystone config when you want to change this.\n\n' +
      schema,
    { parser: 'graphql' }
  );
}

export async function getCommittedArtifacts(
  graphQLSchema: GraphQLSchema,
  config: KeystoneConfig
): Promise<CommittedArtifacts> {
  const lists = initialiseLists(config);
  const prismaSchema = printPrismaSchema(
    lists,
    config.db.provider,
    config.db.prismaPreviewFeatures
  );
  return {
    graphql: getFormattedGraphQLSchema(printSchema(graphQLSchema)),
    prisma: await formatPrismaSchema(prismaSchema),
  };
}

let hasEnsuredBinariesExist = false;
async function ensurePrismaBinariesExist() {
  // ensureBinariesExist does a bunch of slightly expensive things
  // so if we can avoid running it a bunch in tests, that's ideal
  if (hasEnsuredBinariesExist) return;
  // we're resolving @prisma/engines from @prisma/sdk
  // because we don't want to depend on @prisma/engines
  // since its version includes a commit hash from https://github.com/prisma/prisma-engines
  // and we just want to use whatever version @prisma/sdk is using
  // also note we use an exact version of @prisma/sdk
  // so if @prisma/sdk suddenly stops depending on @prisma/engines
  // that won't break a released version of Keystone
  // also, we're not just directly importing @prisma/engines
  // since stricter package managers(e.g. pnpm, Yarn Berry)
  // don't allow importing packages that aren't explicitly depended on
  const requireFromPrismaSdk = createRequire(require.resolve('@prisma/sdk'));
  const prismaEngines = requireFromPrismaSdk('@prisma/engines') as typeof import('@prisma/engines');
  await prismaEngines.ensureBinariesExist();
  hasEnsuredBinariesExist = true;
}

async function formatPrismaSchema(schema: string) {
  await ensurePrismaBinariesExist();
  return formatSchema({ schema });
}

async function readFileButReturnNothingIfDoesNotExist(filename: string) {
  try {
    return await fs.readFile(filename, 'utf8');
  } catch (err: any) {
    if (err.code === 'ENOENT') {
      return;
    }
    throw err;
  }
}

export async function validateCommittedArtifacts(
  graphQLSchema: GraphQLSchema,
  config: KeystoneConfig,
  cwd: string
) {
  const artifacts = await getCommittedArtifacts(graphQLSchema, config);
  const schemaPaths = getSchemaPaths(cwd);
  const [writtenGraphQLSchema, writtenPrismaSchema] = await Promise.all([
    readFileButReturnNothingIfDoesNotExist(schemaPaths.graphql),
    readFileButReturnNothingIfDoesNotExist(schemaPaths.prisma),
  ]);
  const outOfDateSchemas = (() => {
    if (writtenGraphQLSchema !== artifacts.graphql && writtenPrismaSchema !== artifacts.prisma) {
      return 'both';
    }
    if (writtenGraphQLSchema !== artifacts.graphql) {
      return 'graphql';
    }
    if (writtenPrismaSchema !== artifacts.prisma) {
      return 'prisma';
    }
  })();
  if (outOfDateSchemas) {
    const message = {
      both: 'Your Prisma and GraphQL schemas are not up to date',
      graphql: 'Your GraphQL schema is not up to date',
      prisma: 'Your Prisma schema is not up to date',
    }[outOfDateSchemas];
    console.log(message);
    const term = {
      both: 'Prisma and GraphQL schemas',
      prisma: 'Prisma schema',
      graphql: 'GraphQL schema',
    }[outOfDateSchemas];
    if (shouldPrompt && (await confirmPrompt(`Would you like to update your ${term}?`))) {
      await writeCommittedArtifacts(artifacts, cwd);
    } else {
      console.log(`Please run keystone postinstall --fix to update your ${term}`);
      throw new ExitError(1);
    }
  }
}

export async function writeCommittedArtifacts(artifacts: CommittedArtifacts, cwd: string) {
  const schemaPaths = getSchemaPaths(cwd);
  await Promise.all([
    fs.writeFile(schemaPaths.graphql, artifacts.graphql),
    fs.writeFile(schemaPaths.prisma, artifacts.prisma),
  ]);
}

export async function generateCommittedArtifacts(
  graphQLSchema: GraphQLSchema,
  config: KeystoneConfig,
  cwd: string
) {
  const artifacts = await getCommittedArtifacts(graphQLSchema, config);
  await writeCommittedArtifacts(artifacts, cwd);
  return artifacts;
}

const nodeAPIJS = (
  cwd: string,
  config: KeystoneConfig
) => `import keystoneConfig from '../../keystone';
import { PrismaClient } from '.prisma/client';
import { createQueryAPI } from '@keystone-6/core/___internal-do-not-use-will-break-in-patch/node-api';
${makeVercelIncludeTheSQLiteDB(cwd, path.join(cwd, 'node_modules/.keystone/next'), config)}

export const query = createQueryAPI(keystoneConfig, PrismaClient);
`;

const nodeAPIDTS = `import { KeystoneListsAPI } from '@keystone-6/core/types';
import { Context } from './types';

export const query: Context['query'];`;

const makeVercelIncludeTheSQLiteDB = (
  cwd: string,
  directoryOfFileToBeWritten: string,
  config: KeystoneConfig
) => {
  if (config.db.provider === 'sqlite') {
    const sqliteDbAbsolutePath = path.resolve(cwd, config.db.url.replace('file:', ''));

    return `import path from 'path';

    path.join(__dirname, ${JSON.stringify(
      path.relative(directoryOfFileToBeWritten, sqliteDbAbsolutePath)
    )});
    path.join(process.cwd(), ${JSON.stringify(path.relative(cwd, sqliteDbAbsolutePath))});
    `;
  }
  return '';
};

const nextGraphQLAPIJS = (
  cwd: string,
  config: KeystoneConfig
) => `import keystoneConfig from '../../../keystone';
import { PrismaClient } from '.prisma/client';
import { nextGraphQLAPIRoute } from '@keystone-6/core/___internal-do-not-use-will-break-in-patch/next-graphql';
${makeVercelIncludeTheSQLiteDB(cwd, path.join(cwd, 'node_modules/.keystone/next'), config)}

export const config = {
  api: {
    bodyParser: false,
  },
};

export default nextGraphQLAPIRoute(keystoneConfig, PrismaClient);
`;

// note the export default config is just a lazy way of going "this is also any"
const nextGraphQLAPIDTS = `export const config: any;
export default config;
`;

const graphqlTsAPI = `import * as graphqlTsSchema from '@keystone-6/core/___internal-do-not-use-will-break-in-patch/graphql-ts';
import type { Context } from '../types';
export * from '@keystone-6/core/___internal-do-not-use-will-break-in-patch/graphql-ts-without-context';
export { field, fields, interface, interfaceField, object, union } from './graphql-ts-with-context';

export type { Context }

export type NullableType = graphqlTsSchema.NullableType<Context>;
export type Type = graphqlTsSchema.Type<Context>;
export type NullableOutputType = graphqlTsSchema.NullableOutputType<Context>;
export type OutputType = graphqlTsSchema.OutputType<Context>;
export type Field<
  Source,
  Args extends Record<string, graphqlTsSchema.Arg<any>>,
  TType extends OutputType,
  Key extends string
> = graphqlTsSchema.Field<Source, Args, TType, Key, Context>;
export type FieldResolver<
  Source,
  Args extends Record<string, graphqlTsSchema.Arg<any>>,
  TType extends OutputType
> = graphqlTsSchema.FieldResolver<Source, Args, TType, Context>;
export type ObjectType<Source> = graphqlTsSchema.ObjectType<Source, Context>;
export type UnionType<Source> = graphqlTsSchema.UnionType<Source, Context>;
export type InterfaceType<
  Source,
  Fields extends Record<string, graphqlTsSchema.InterfaceField<any, OutputType, Context>>
> = graphqlTsSchema.InterfaceType<Source, Fields, Context>;
export type InterfaceField<
  Args extends Record<string, graphqlTsSchema.Arg<any>>,
  TType extends OutputType
> = graphqlTsSchema.InterfaceField<Args, TType, Context>;
`;

// this whole export = thing is just so that ts retains JSDoc comments (the alternative of creating a variable does not preserve them)
const graphqlTsWithContextAPI = `import { GraphQLSchemaAPIWithContext } from '@keystone-6/core/___internal-do-not-use-will-break-in-patch/graphql-ts';
import { Context } from './graphql-ts';

declare const __graphql: GraphQLSchemaAPIWithContext<Context>;

export = __graphql;
`;

export async function generateDotKeystoneJSFile(cwd: string) {
  const dotKeystoneDir = path.join(cwd, 'node_modules/.keystone');
  await fs.outputFile(
    path.join(dotKeystoneDir, 'index.js'),
    "exports.graphql = require('@keystone-6/core').graphql;"
  );
}

function throwIfProblematicError(err: any) {
  if (err.code !== 'ENOENT') {
    throw err;
  }
}

export async function generateNodeModulesArtifactsWithoutPrismaClient(
  graphQLSchema: GraphQLSchema,
  config: KeystoneConfig,
  cwd: string
) {
  const lists = initialiseLists(config);

  const dotKeystoneDir = path.join(cwd, 'node_modules/.keystone');
  await Promise.all([
    // this is so that when you upgrade from a keystone version that generates `.keystone/types` to `.keystone`
    // and then .keystone/types sort of works locally but it doesn't update when you make new changes
    // and your CI or etc. breaks and you're confused as to why
    // this could be swapped to a "find all the things that aren't generated by keystone today and delete those"
    // but that would be a bunch more code when we know there are the only things that should exist right now
    fs.unlink(path.join(dotKeystoneDir, 'types.js')).catch(throwIfProblematicError),
    fs.unlink(path.join(dotKeystoneDir, 'types.d.ts')).catch(throwIfProblematicError),
    fs.outputFile(
      path.join(dotKeystoneDir, 'index.d.ts'),
      printGeneratedTypes(graphQLSchema, lists)
    ),
    fs.outputFile(path.join(dotKeystoneDir, 'internal/graphql-ts.d.ts'), graphqlTsAPI),
    fs.outputFile(
      path.join(dotKeystoneDir, 'internal/graphql-ts-with-context.d.ts'),
      graphqlTsWithContextAPI
    ),
    generateDotKeystoneJSFile(cwd),
    ...(config.experimental?.generateNodeAPI
      ? [
          fs.outputFile(path.join(dotKeystoneDir, 'api.js'), nodeAPIJS(cwd, config)),
          fs.outputFile(path.join(dotKeystoneDir, 'api.d.ts'), nodeAPIDTS),
        ]
      : []),
    ...(config.experimental?.generateNextGraphqlAPI
      ? [
          fs.outputFile(
            path.join(dotKeystoneDir, 'next/graphql-api.js'),
            nextGraphQLAPIJS(cwd, config)
          ),
          fs.outputFile(path.join(dotKeystoneDir, 'next/graphql-api.d.ts'), nextGraphQLAPIDTS),
        ]
      : []),
  ]);
}

export async function generateNodeModulesArtifacts(
  graphQLSchema: GraphQLSchema,
  config: KeystoneConfig,
  cwd: string
) {
  await Promise.all([
    generatePrismaClient(cwd),
    generateNodeModulesArtifactsWithoutPrismaClient(graphQLSchema, config, cwd),
  ]);
}

async function generatePrismaClient(cwd: string) {
  const generator = await getGenerator({ schemaPath: getSchemaPaths(cwd).prisma });
  try {
    await generator.generate();
  } finally {
    let closePromise = new Promise<void>(resolve => {
      const child = (generator as any).generatorProcess
        .child as import('child_process').ChildProcess;
      child.once('exit', () => {
        resolve();
      });
    });
    generator.stop();
    await closePromise;
  }
}

export function requirePrismaClient(cwd: string) {
  return require(path.join(cwd, 'node_modules/.prisma/client')).PrismaClient;
}
