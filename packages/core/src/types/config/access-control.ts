import type { MaybePromise } from '../utils';
import type { KeystoneContextFromListTypeInfo } from '..';
import { BaseListTypeInfo, BaseSingletonTypeInfo, BaseSchemaTypeInfo } from '../type-info';

type BaseAccessArgs<SchemaTypeInfo extends BaseSchemaTypeInfo> = {
  session: any;
  listKey: string;
  context: KeystoneContextFromListTypeInfo<SchemaTypeInfo>;
};

// List Filter Access

type FilterOutput<ListTypeInfo extends BaseListTypeInfo> =
  | boolean
  | ListTypeInfo['inputs']['where'];

export type ListFilterAccessControl<
  Operation extends 'query' | 'update' | 'delete',
  ListTypeInfo extends BaseListTypeInfo
> = (
  args: BaseAccessArgs<ListTypeInfo> & { operation: Operation }
) => MaybePromise<FilterOutput<ListTypeInfo>>;

// List Item Access

type CreateItemAccessArgs<SchemaTypeInfo extends BaseSchemaTypeInfo> =
  BaseAccessArgs<SchemaTypeInfo> & {
    operation: 'create';
    /**
     * The input passed in from the GraphQL API
     */
    inputData: GetCreateInput<SchemaTypeInfo>;
  };

export type GetCreateInput<SchemaTypeInfo extends BaseSchemaTypeInfo> =
  SchemaTypeInfo extends BaseListTypeInfo ? SchemaTypeInfo['inputs']['create'] : any;

export type CreateListItemAccessControl<ListTypeInfo extends BaseListTypeInfo> = (
  args: CreateItemAccessArgs<ListTypeInfo>
) => MaybePromise<boolean>;

type UpdateItemAccessArgs<SchemaTypeInfo extends BaseSchemaTypeInfo> =
  BaseAccessArgs<SchemaTypeInfo> & {
    operation: 'update';
    /**
     * The item being updated
     */
    item: SchemaTypeInfo['item'];
    /**
     * The input passed in from the GraphQL API
     */
    inputData: SchemaTypeInfo['inputs']['update'];
  };

export type UpdateListItemAccessControl<SchemaTypeInfo extends BaseSchemaTypeInfo> = (
  args: UpdateItemAccessArgs<SchemaTypeInfo>
) => MaybePromise<boolean>;

type DeleteItemAccessArgs<ListTypeInfo extends BaseListTypeInfo> = BaseAccessArgs<ListTypeInfo> & {
  operation: 'delete';
  /**
   * The item being deleted
   */
  item: ListTypeInfo['item'];
};

export type DeleteListItemAccessControl<ListTypeInfo extends BaseListTypeInfo> = (
  args: DeleteItemAccessArgs<ListTypeInfo>
) => MaybePromise<boolean>;

export type ListOperationAccessControl<
  Operation extends 'create' | 'query' | 'update' | 'delete',
  SchemaTypeInfo extends BaseSchemaTypeInfo
> = (args: BaseAccessArgs<SchemaTypeInfo> & { operation: Operation }) => MaybePromise<boolean>;

// List level access control lets you set permissions on the autogenerated CRUD API for each list.
//
// * `operation` access lets you check the information in the `context` and `session` objects to decide if the
// user is allow to access the list.
// * `filter` access lets you provide a GraphQL filter which defines the items the user is allowed to access.
// * `item` access lets you write a function which inspects the provided input data and the existing object (if it exists)
// and make a decision based on this extra data.
//
// If access is denied due to any of the access control methods then the following response will be returned from the GraphQL API:
//   Mutations:
//     - Single operations will return `null` and return an access denied error
//     - Multi operations will return a data array with `null` values for the items which have access denied.
//       Access denied errors will be return for each `null` items.
//   Queries:
//     - Single item queries will return `null` with no errors.
//     - Many item queries will filter out those items which have access denied, with no errors.
//     - Count queries will only count those items for which access is not denied, with no errors.
//
export type ListAccessControl<ListTypeInfo extends BaseListTypeInfo> = {
  // These functions should return `true` if access is allowed or `false` if access is denied.
  operation?: {
    query?: ListOperationAccessControl<'query', ListTypeInfo>;
    create?: ListOperationAccessControl<'create', ListTypeInfo>;
    update?: ListOperationAccessControl<'update', ListTypeInfo>;
    delete?: ListOperationAccessControl<'delete', ListTypeInfo>;
  };

  // The 'filter' rules can return either:
  // - a filter. In this case, the operation can proceed, but the filter will be additionally applied when updating/reading/deleting
  //   which may make it appear that some of the items don't exist.
  // - boolean true/false. If false, treated as a filter that never matches.
  filter?: {
    query?: ListFilterAccessControl<'query', ListTypeInfo>;
    update?: ListFilterAccessControl<'update', ListTypeInfo>;
    delete?: ListFilterAccessControl<'delete', ListTypeInfo>;
    // create: not supported: FIXME: Add explicit check that people don't try this.
    // FIXME: Write tests for parseAccessControl.
  };

  // These rules are applied to each item being operated on individually. They return `true` or `false`,
  // and if false, an access denied error will be returned for the individual operation.
  item?: {
    // query: not supported
    create?: CreateListItemAccessControl<ListTypeInfo>;
    update?: UpdateListItemAccessControl<ListTypeInfo>;
    delete?: DeleteListItemAccessControl<ListTypeInfo>;
  };
};

type ReadItemAccessArgs<ListTypeInfo extends BaseSingletonTypeInfo> =
  BaseAccessArgs<ListTypeInfo> & {
    operation: 'read';
    /**
     * The item being read
     */
    item: ListTypeInfo['item'];
  };

export type SingletonAccessControl<ListTypeInfo extends BaseSingletonTypeInfo> = {
  // These functions should return `true` if access is allowed or `false` if access is denied.
  operation?: {
    query?: ListOperationAccessControl<'query', ListTypeInfo>;
    update?: ListOperationAccessControl<'update', ListTypeInfo>;
  };

  // These rules are applied to each item being operated on individually. They return `true` or `false`,
  // and if false, an access denied error will be returned for the individual operation.
  item?: {
    read?: ReadItemAccessArgs<ListTypeInfo>;
    update?: UpdateListItemAccessControl<ListTypeInfo>;
  };
};

// Field Access
export type IndividualFieldAccessControl<Args> = (args: Args) => MaybePromise<boolean>;

export type FieldCreateItemAccessArgs<SchemaTypeInfo extends BaseSchemaTypeInfo> =
  CreateItemAccessArgs<SchemaTypeInfo> & { fieldKey: string };

export type FieldReadItemAccessArgs<SchemaTypeInfo extends BaseSchemaTypeInfo> =
  BaseAccessArgs<SchemaTypeInfo> & {
    operation: 'read';
    fieldKey: string;
    item: SchemaTypeInfo['item'];
  };

export type FieldUpdateItemAccessArgs<SchemaTypeInfo extends BaseSchemaTypeInfo> =
  UpdateItemAccessArgs<SchemaTypeInfo> & { fieldKey: string };

export type FieldAccessControl<SchemaTypeInfo extends BaseSchemaTypeInfo> =
  | {
      read?: IndividualFieldAccessControl<FieldReadItemAccessArgs<SchemaTypeInfo>>;
      create?: IndividualFieldAccessControl<FieldCreateItemAccessArgs<SchemaTypeInfo>>;
      update?: IndividualFieldAccessControl<FieldUpdateItemAccessArgs<SchemaTypeInfo>>;
    }
  | IndividualFieldAccessControl<
      | FieldCreateItemAccessArgs<SchemaTypeInfo>
      | FieldReadItemAccessArgs<SchemaTypeInfo>
      | FieldUpdateItemAccessArgs<SchemaTypeInfo>
    >;
